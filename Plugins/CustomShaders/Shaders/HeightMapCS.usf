// Compute shader to generate TerraShift height map
#include "/Engine/Public/Platform.ush"

RWStructuredBuffer<float> OutHeightMap;
StructuredBuffer<float3>  ColumnCenters;
StructuredBuffer<float3>  ColumnRadiiArray;
StructuredBuffer<float3>  ObjCenters;
StructuredBuffer<float3>  ObjRadii;
float ColZBias;
float ObjZBias;

// Try removing cbuffer and use direct parameter declarations
// cbuffer Parameters
// {
    float2 PlatformSize;
    int    GridSize;
    int    StateW;
    int    StateH;
    float  CellSize;
    float  MinZ;
    float  MaxZ;
    float3 ColumnRadii;
    int    NumObjects;
// };

// No wave sampling: heights come from column and object ellipsoids directly

[numthreads(16,16,1)]
void MainCS(uint3 DTid : SV_DispatchThreadID)
{
    if (DTid.x >= (uint)StateW || DTid.y >= (uint)StateH)
        return;

    // Map pixel to platform-local coordinates
    float nx = (StateW > 1) ? (DTid.x / (float)(StateW - 1)) : 0.5;
    float ny = (StateH > 1) ? (DTid.y / (float)(StateH - 1)) : 0.5;
    float lx = (nx - 0.5) * PlatformSize.x;
    float ly = (ny - 0.5) * PlatformSize.y;

    // Baseline from columns/objects
    float z = MinZ;

    // Column curvature overlay - Consider up to 4 nearest column centers (like CPU version)
    float halfX = PlatformSize.x * 0.5;
    float halfY = PlatformSize.y * 0.5;
    float fx = (lx + halfX) / max(CellSize, 1e-6) - 0.5;
    float fy = (ly + halfY) / max(CellSize, 1e-6) - 0.5;
    int ix0 = clamp((int)floor(fx), 0, GridSize - 1);
    int iy0 = clamp((int)floor(fy), 0, GridSize - 1);
    int ix1 = clamp(ix0 + 1, 0, GridSize - 1);
    int iy1 = clamp(iy0 + 1, 0, GridSize - 1);

    // Check 4 candidate columns to create continuous surface.
    // y-major indexing: idx = y * GridSize + x
    int candIdx[4] = { iy0 * GridSize + ix0, iy1 * GridSize + ix0, iy0 * GridSize + ix1, iy1 * GridSize + ix1 };

    for (int k = 0; k < 4; ++k)
    {
        int ci = candIdx[k];
        if (ci < 0 || ci >= GridSize * GridSize) continue;

        // Column center and radii from buffers (platform-local)
        float3 cc = ColumnCenters[ci];
        float3 cr = ColumnRadiiArray[ci];
        float zCenter = cc.z;
        float rx = max(cr.x, 1e-6);
        float ry = max(cr.y, 1e-6);
        float rz = max(cr.z, 1e-6);

        // Ensure minimum radius
        rx = max(rx, 1e-6);
        ry = max(ry, 1e-6);

        // Column center position from buffer (platform-local)
        float cx = cc.x;
        float cy = cc.y;

        float dx = lx - cx;
        float dy = ly - cy;
        float nxr = dx / rx;
        float nyr = dy / ry;
        float r2 = nxr*nxr + nyr*nyr;
        if (r2 <= 1.0)
        {
            float candidateZ = (zCenter + ColZBias) + rz * sqrt(max(0.0, 1.0 - r2));
            z = max(z, candidateZ);
        }
    }

    // GridObjects overlay
    [loop]
    for (int i = 0; i < NumObjects; ++i)
    {
        float3 oc = ObjCenters[i];
        float2 ocxy = oc.xy;
        float3 orad = ObjRadii[i];
        float odx = lx - ocxy.x;
        float ody = ly - ocxy.y;
        float onx = odx / max(orad.x, 1e-6);
        float ony = ody / max(orad.y, 1e-6);
        float or2 = onx*onx + ony*ony;
        if (or2 <= 1.0)
        {
            float candidateZ = (oc.z + ObjZBias) + orad.z * sqrt(max(0.0, 1.0 - or2));
            z = max(z, candidateZ);
        }
    }

    // Normalize Z like CPU path: (z - MinZ) / (MaxZ - MinZ) -> [-1,1]
    float zClamped = clamp(z, MinZ, MaxZ);
    float rangeZ = max(MaxZ - MinZ, 1e-6);
    float zNormalized = (zClamped - MinZ) / rangeZ;
    float normNegPos = clamp(zNormalized * 2.0 - 1.0, -1.0, 1.0);

    uint outIndex = DTid.y * StateW + DTid.x;
    OutHeightMap[outIndex] = normNegPos;
}
