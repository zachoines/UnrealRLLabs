// Compute shader to generate TerraShift height map
#include "/Engine/Public/Platform.ush"

RWStructuredBuffer<float> OutHeightMap;
StructuredBuffer<float>   WaveHeights;
StructuredBuffer<float3>  ObjCenters;
StructuredBuffer<float3>  ObjRadii;

// Try removing cbuffer and use direct parameter declarations
// cbuffer Parameters
// {
    float2 PlatformSize;
    int    GridSize;
    int    StateW;
    int    StateH;
    float  CellSize;
    float  MinZ;
    float  MaxZ;
    float3 ColumnRadii;
    int    NumObjects;
// };

// Bilinear sample wave grid in [0..GridSize-1] - RESTORED
float SampleWave(float2 gridUV, int gridSize)
{
    float x = clamp(gridUV.x, 0.0, gridSize - 1.0);
    float y = clamp(gridUV.y, 0.0, gridSize - 1.0);
    int x0 = (int)floor(x);
    int y0 = (int)floor(y);
    int x1 = min(x0 + 1, gridSize - 1);
    int y1 = min(y0 + 1, gridSize - 1);
    float fx = x - (float)x0;
    float fy = y - (float)y0;
    int idx00 = y0 * gridSize + x0;
    int idx01 = y1 * gridSize + x0;
    int idx10 = y0 * gridSize + x1;
    int idx11 = y1 * gridSize + x1;
    float v0 = lerp(WaveHeights[idx00], WaveHeights[idx01], fy);
    float v1 = lerp(WaveHeights[idx10], WaveHeights[idx11], fy);
    return lerp(v0, v1, fx);
}

[numthreads(16,16,1)]
void MainCS(uint3 DTid : SV_DispatchThreadID)
{
    if (DTid.x >= (uint)StateW || DTid.y >= (uint)StateH)
        return;

    // Map pixel to platform-local coordinates
    float nx = (StateW > 1) ? (DTid.x / (float)(StateW - 1)) : 0.5;
    float ny = (StateH > 1) ? (DTid.y / (float)(StateH - 1)) : 0.5;
    float lx = (nx - 0.5) * PlatformSize.x;
    float ly = (ny - 0.5) * PlatformSize.y;

    // Baseline from wave
    float gridX = nx * (GridSize - 1);
    float gridY = ny * (GridSize - 1);
    float z = SampleWave(float2(gridX, gridY), GridSize);

    // Column curvature overlay - Consider up to 4 nearest column centers (like CPU version)
    float halfX = PlatformSize.x * 0.5;
    float halfY = PlatformSize.y * 0.5;
    float fx = (lx + halfX) / max(CellSize, 1e-6) - 0.5;
    float fy = (ly + halfY) / max(CellSize, 1e-6) - 0.5;
    int ix0 = clamp((int)floor(fx), 0, GridSize - 1);
    int iy0 = clamp((int)floor(fy), 0, GridSize - 1);
    int ix1 = clamp(ix0 + 1, 0, GridSize - 1);
    int iy1 = clamp(iy0 + 1, 0, GridSize - 1);

    // Check 4 candidate columns to create continuous surface
    int candIdx[4] = { ix0 * GridSize + iy0, ix0 * GridSize + iy1, ix1 * GridSize + iy0, ix1 * GridSize + iy1 };

    for (int k = 0; k < 4; ++k)
    {
        int ci = candIdx[k];
        if (ci < 0 || ci >= GridSize * GridSize) continue;

        float zCenter = WaveHeights[ci];
        // Calculate correct column radii based on Grid.cpp initialization
        // Grid.cpp line 24: FVector(1.0 / GridSize, 1.0 / GridSize, 2.0 / GridSize)
        float rx = (1.0 / (float)GridSize) * PlatformSize.x;  // Should fill cell space
        float ry = (1.0 / (float)GridSize) * PlatformSize.y;  // Should fill cell space
        float rz = max(ColumnRadii.z, 1e-6);  // Keep Z scaling from ColumnRadii

        // Ensure minimum radius
        rx = max(rx, 1e-6);
        ry = max(ry, 1e-6);

        // Column center position for this candidate
        int col_ix = ci / GridSize;
        int col_iy = ci % GridSize;
        float cx = (col_ix + 0.5) * CellSize - halfX;
        float cy = (col_iy + 0.5) * CellSize - halfY;

        float dx = lx - cx;
        float dy = ly - cy;
        float nxr = dx / rx;
        float nyr = dy / ry;
        float r2 = nxr*nxr + nyr*nyr;
        if (r2 <= 1.0)
        {
            float zTop = zCenter + rz * sqrt(max(0.0, 1.0 - r2));
            z = max(z, zTop);
        }
    }

    // GridObjects overlay
    [loop]
    for (int i = 0; i < NumObjects; ++i)
    {
        float3 oc = ObjCenters[i];
        float3 orad = ObjRadii[i];
        float odx = lx - oc.x;
        float ody = ly - oc.y;
        float onx = odx / max(orad.x, 1e-6);
        float ony = ody / max(orad.y, 1e-6);
        float or2 = onx*onx + ony*ony;
        if (or2 <= 1.0)
        {
            float zTopObj = oc.z + orad.z * sqrt(max(0.0, 1.0 - or2));
            z = max(z, zTopObj);
        }
    }

    // Perspective-correct normalization
    float zClamped = clamp(z, MinZ, MaxZ);
    float xyRange = max(PlatformSize.x, PlatformSize.y);
    float zNormalized = (zClamped - MinZ) / xyRange;
    float normNegPos = clamp(zNormalized * 2.0 - 1.0, -1.0, 1.0);

    uint outIndex = DTid.y * StateW + DTid.x;
    OutHeightMap[outIndex] = normNegPos;
}

